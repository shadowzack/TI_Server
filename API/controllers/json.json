[{
	"_id": "5c7369b44a27ac604baaae71",
	"source": "agda",
	"year": [{
		"year": "2018",
		"tags": [{
			"tag": "haskell"
		}, {
			"tag": "idris"
		}, {
			"tag": "dependent-type"
		}, {
			"tag": "coq"
		}, {
			"tag": "functional-programming"
		}, {
			"tag": "theorem-proving"
		}]
	}, {
		"year": "2017",
		"tags": [{
			"tag": "functional-programming"
		}, {
			"tag": "dependent-type"
		}, {
			"tag": "idris"
		}, {
			"tag": "coq"
		}, {
			"tag": "agda-mode"
		}, {
			"tag": "proof"
		}, {
			"tag": "theorem-proving"
		}, {
			"tag": "haskell"
		}, {
			"tag": "pattern-matching"
		}, {
			"tag": "types"
		}, {
			"tag": "dictionary"
		}, {
			"tag": "functor"
		}, {
			"tag": "emacs"
		}, {
			"tag": "io"
		}, {
			"tag": "coinduction"
		}]
	}, {
		"year": "2016",
		"tags": [{
			"tag": "dependent-type"
		}, {
			"tag": "haskell"
		}, {
			"tag": "types"
		}, {
			"tag": "functional-programming"
		}, {
			"tag": "idris"
		}, {
			"tag": "emacs"
		}, {
			"tag": "type-theory"
		}, {
			"tag": "pattern-matching"
		}, {
			"tag": "equality"
		}, {
			"tag": "coq"
		}, {
			"tag": "theorem-proving"
		}, {
			"tag": "morte"
		}, {
			"tag": "boolean"
		}, {
			"tag": "record"
		}, {
			"tag": "observational-type-theory"
		}, {
			"tag": "standard-library"
		}, {
			"tag": "agda-mode"
		}, {
			"tag": "logic"
		}, {
			"tag": "list"
		}]
	}, {
		"year": "2015",
		"tags": [{
			"tag": "dependent-type"
		}, {
			"tag": "functional-programming"
		}, {
			"tag": "haskell"
		}, {
			"tag": "types"
		}, {
			"tag": "type-theory"
		}, {
			"tag": "idris"
		}, {
			"tag": "theorem-proving"
		}, {
			"tag": "proof"
		}, {
			"tag": "category-theory"
		}, {
			"tag": "algebra"
		}, {
			"tag": "parametric-polymorphism"
		}, {
			"tag": "generic-programming"
		}, {
			"tag": "equality"
		}, {
			"tag": "observational-type-theory"
		}, {
			"tag": "pattern-matching"
		}, {
			"tag": "recursion"
		}, {
			"tag": "stream"
		}]
	}, {
		"year": "2014",
		"tags": [{
			"tag": "idris"
		}, {
			"tag": "dependent-type"
		}, {
			"tag": "coq"
		}, {
			"tag": "termination"
		}, {
			"tag": "proof"
		}, {
			"tag": "haskell"
		}, {
			"tag": "equality"
		}, {
			"tag": "types"
		}, {
			"tag": "theorem-proving"
		}, {
			"tag": "pattern-matching"
		}, {
			"tag": "isabelle"
		}, {
			"tag": "standard-library"
		}, {
			"tag": "monads"
		}, {
			"tag": "substitution"
		}, {
			"tag": "algebraic-data-types"
		}, {
			"tag": "io"
		}, {
			"tag": "type-theory"
		}, {
			"tag": "record"
		}, {
			"tag": "emacs"
		}, {
			"tag": "functor"
		}, {
			"tag": "logic"
		}, {
			"tag": "parametric-polymorphism"
		}, {
			"tag": "recursion"
		}]
	}, {
		"year": "2013",
		"tags": [{
			"tag": "haskell"
		}, {
			"tag": "dependent-type"
		}, {
			"tag": "proof"
		}, {
			"tag": "types"
		}, {
			"tag": "module"
		}, {
			"tag": "functional-programming"
		}]
	}]
}]